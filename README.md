
<figure class="aligncenter size-large"><img decoding="async" width="1024" height="576" src="./Cryptanalysis of the DAO exploit - Multi-Stage Attack - CRYPTO DEEP TECH_files/044-1024x576.png" alt="Cryptanalysis of the DAO exploit &amp; Multi-Stage Attack" class="wp-image-2342" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/044-1024x576.png 1024w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/044-300x169.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/044-768x432.png 768w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/044.png 1280w" sizes="(max-width: 1024px) 100vw, 1024px"></figure></div>


<p></p>



<p>In this article, we will look at a bug in the DAO code. The hacker exploited a bug in the code of the DAO and stole more or less $50 million worth of ether. I will focus here only on the main technical issue of the exploit: The fallback function. For a more detailed and advanced recount of the attack, the blog posts by&nbsp;Phil Daian&nbsp;and&nbsp;Peter Vessenes&nbsp;are highly recommended.</p>



<p>This post will be the first in what is potentially a series, deconstructing and explaining what went wrong at the technical level while providing a timeline tracing the actions of the attacker back through the blockchain. This first post will focus on&nbsp;<em>how</em>&nbsp;exactly the attacker stole all the money in the DAO.</p>



<h2 class="wp-block-heading">A Multi-Stage Attack</h2>



<p>This exploit in the DAO is clearly not trivial; the exact programming pattern that made the DAO vulnerable was not only known, but&nbsp;<a href="https://blog.slock.it/no-dao-funds-at-risk-following-the-ethereum-smart-contract-recursive-call-bug-discovery-29f482d348b">fixed by the DAO creators themselves in an earlier intended update to the framework’s code</a>. Ironically, as they were writing their blog posts and claiming victory, the hacker was preparing and deploying an exploit that targeted the same function they had just fixed to drain the DAO of all its funds.</p>



<p>Let’s get into the overview of the attack. The attacker was analyzing DAO.sol, and noticed that the ‘splitDAO’ function was vulnerable to the recursive send pattern we’ve described above: this function updates user balances and totals at the end, so if we can get any of the function calls before this happens to call splitDAO again, we get the infinite recursion that can be used to move as many funds as we want (code comments are marked with XXXXX, you may have to scroll to see em):</p>



<pre class="wp-block-preformatted">function splitDAO(
  uint _proposalID,
  address _newCurator
) noEther onlyTokenholders returns (bool _success) {

  ...
  // XXXXX Move ether and assign new Tokens.  Notice how this is done first!
  uint fundsToBeMoved =
      (balances[msg.sender] * p.splitData[0].splitBalance) /
      p.splitData[0].totalSupply;
  if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false) // XXXXX This is the line the attacker wants to run more than once
      throw;

  ...
  // Burn DAO Tokens
  Transfer(msg.sender, 0, balances[msg.sender]);
  withdrawRewardFor(msg.sender); // be nice, and get his rewards
  // XXXXX Notice the preceding line is critically before the next few
  totalSupply -= balances[msg.sender]; // XXXXX AND THIS IS DONE LAST
  balances[msg.sender] = 0; // XXXXX AND THIS IS DONE LAST TOO
  paidOut[msg.sender] = 0;
  return true;
}
</pre>



<p>The basic idea is this: propose a split. Execute the split. When the DAO goes to withdraw your reward, call the function to execute a split before that withdrawal finishes. The function will start running&nbsp;<strong>without updating your balance</strong>, and the line we marked above as “the attacker wants to run more than once” will run more than once. What does that do? Well, the source code is in&nbsp;<a href="https://github.com/slockit/DAO/blob/v1.0/TokenCreation.sol">TokenCreation.sol</a>, and it transfers tokens from the parent DAO to the child DAO. Basically the attacker is using this to transfer more tokens than they should be able to into their child DAO.</p>



<p>How does the DAO decide how many tokens to move? Using the balances array of course:</p>



<pre class="wp-block-preformatted">uint fundsToBeMoved = (balances[msg.sender] * p.splitData[0].splitBalance) / p.splitData[0].totalSupply;
</pre>



<p>Because p.splitData[0] is going to be the same every time the attacker calls this function (it’s a property of the proposal p, not the general state of the DAO), and because the attacker can call this function from withdrawRewardFor&nbsp;<strong>before the balances array is updated</strong>, the attacker can get this code to run arbitrarily many times using the described attack, with fundsToBeMoved coming out to the same value each time.</p>



<p>The first thing the attacker needed to do to pave the way for his successful exploit was to have the withdraw function for the DAO, which was vulnerable to the critical recursive send exploit, actually run. Let’s look at what’s required to make that happen in code (from DAO.sol):</p>



<pre class="wp-block-preformatted">function withdrawRewardFor(address _account) noEther internal returns (bool _success) {
  if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply &lt; paidOut[_account])
    throw;

  uint reward =
    (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];
  if (!rewardAccount.payOut(_account, reward)) // XXXXX vulnerable
    throw;
  paidOut[_account] += reward;
  return true;
}
</pre>



<p>If the hacker could get the first if statement to evaluate to false, the statement marked vulnerable would run. When that statements runs, code that looks like this would be called:</p>



<pre class="wp-block-preformatted">function payOut(address _recipient, uint _amount) returns (bool) {
  if (msg.sender != owner || msg.value &gt; 0 || (payOwnerOnly &amp;&amp; _recipient != owner))
      throw;
  if (_recipient.call.value(_amount)()) { // XXXXX vulnerable
      PayOut(_recipient, _amount);
      return true;
  } else {
      return false;
}
</pre>



<p>Notice how the marked line is exactly the vulnerable code mentioned in the&nbsp;<a href="http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/">description of the exploit</a>&nbsp;we linked!</p>



<p>That line would then send a message from the DAO’s contract to “_recipient” (the attacker). “_recipient” would of course contain a default function, that would call splitDAO again with the same parameters as the initial call from the attacker. Remember that because this is all happening from inside withdrawFor from inside splitDAO, the code updating the balances in splitDAO hasn’t run. So the split will send more tokens to the child DAO, and then ask for the reward to be withdrawn again. Which will try to send tokens to “_recipient” again, which would again call split DAO before updating the balances array.</p>



<p>And so it goes:</p>



<ol>
<li>Propose a split and wait until the voting period expires.&nbsp;<em>(DAO.sol, createProposal)</em></li>



<li>Execute the split.&nbsp;<em>(DAO.sol, splitDAO)</em></li>



<li>Let the DAO send your new DAO its share of tokens.&nbsp;<em>(splitDAO -&gt; TokenCreation.sol, createTokenProxy)</em></li>



<li>Make sure the DAO tries to send you a reward before it updates your balance but after doing (3).&nbsp;<em>(splitDAO -&gt; withdrawRewardFor -&gt; ManagedAccount.sol, payOut)</em></li>



<li>While the DAO is doing (4), have it run splitDAO again with the same parameters as in (2)&nbsp;<em>(payOut -&gt; _recipient.call.value -&gt; _recipient())</em></li>



<li>The DAO will now send you more child tokens, and go to withdraw your reward before updating your balance.&nbsp;<em>(DAO.sol, splitDAO)</em></li>



<li>Back to (5)!</li>



<li>Let the DAO update your balance. Because (7) goes back to (5), it never actually will :-).</li>
</ol>



<p>(Side note: Ethereum’s gas mechanics don’t save us here. call.value passes on all the gas a transaction is working with by default, unlike the send function. so the code will run as long as the attacker will pay for it, which considering it’s a cheap exploit means indefinitely)</p>



<p>Armed with this, we can provide a step by step re-trace of how The DAO got emptied out.</p>



<h2 class="wp-block-heading">Step 1: Proposing the Split</h2>



<p>The first step towards all of the above is to simply propose a regular split, as we’ve mentioned.</p>



<p>The attacker does this in the blockchain&nbsp;<a href="https://live.ether.camp/transaction/5798fbc45e3b63832abc4984b0f3574a13545f415dd672cd8540cd71f735db56">here</a>&nbsp;in DAO Proposal #59, with the title “Lonely, so Lonely”.</p>



<p>Because of this line:</p>



<pre class="wp-block-preformatted">// The minimum debate period that a split proposal can have
uint constant minSplitDebatePeriod = 1 weeks;
</pre>



<p>he had to wait a week for the proposal to see approval. No matter, it’s just a split proposal like any other! Nobody will look too closely at it, right?</p>



<h2 class="wp-block-heading">Step 2: Getting the Reward</h2>



<p>As was neatly explained in one of&nbsp;<a href="https://blog.slock.it/no-dao-funds-at-risk-following-the-ethereum-smart-contract-recursive-call-bug-discovery-29f482d348b">slock.it’s previous posts on the matter</a>, there are no rewards for the DAO to give out yet! (because no rewards were generated).</p>



<p>As we mentioned in the overview, the critical lines that need to run here are:</p>



<pre class="wp-block-preformatted">function withdrawRewardFor(address _account) noEther internal returns (bool _success) {
  if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply &lt; paidOut[_account]) // XXXXX
    throw;

  uint reward =
    (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];
  if (!rewardAccount.payOut(_account, reward)) // XXXXX
    throw;
  paidOut[_account] += reward;
  return true;
}
</pre>



<p>If the hacker could get the first marked line to run, the second marked line will run the default function of his choosing (that calls back to splitDAO as we described previously).</p>



<p>Let’s deconstruct the first if statement:</p>



<pre class="wp-block-preformatted">if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply &lt; paidOut[_account])
</pre>



<p>The balanceOf function is defined in&nbsp;<a href="https://github.com/slockit/DAO/blob/develop/Token.sol">Token.sol</a>, and of course does exactly this:</p>



<pre class="wp-block-preformatted">return balances[_owner];
</pre>



<p>The rewardAccount.accumulatedInput() line is evaluated from code in&nbsp;<a href="https://github.com/slockit/DAO/blob/v1.0/ManagedAccount.sol">ManagedAccount.sol</a>:</p>



<pre class="wp-block-preformatted">// The sum of ether (in wei) which has been sent to this contract
uint public accumulatedInput;
</pre>



<p>Luckily accumulatedInput is oh so simple to manipulate. Just use the default function of the reward account!</p>



<pre class="wp-block-preformatted">function() {
    accumulatedInput += msg.value;
}
</pre>



<p>Not only that, but because there is no logic to decrease accumulatedInput anywhere (it tracks the input the account has gotten from all the transactions ever), all the attacker needs to do is send a few Wei to the reward account and our original condition will not only evaluate to false, but its constituent values will evaluate to the same thing every time it’s called:</p>



<pre class="wp-block-preformatted">if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply &lt; paidOut[_account])
</pre>



<p>Remember that because balanceOf refers to balances, which never gets updated, and because paidOut and totalSupply also never get updated since that code in splitDAO never actually executes, the attacker gets to claim their tiny share of the reward with no problems. And because they can claim their share of the reward, they can run their default function and reenter back to splitDAO. Whoopsie.</p>



<p>But do they actually need to include a reward? Let’s look at the line again:</p>



<pre class="wp-block-preformatted">if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply &lt; paidOut[_account])
</pre>



<p>What if the reward account balance is 0? Then we get</p>



<pre class="wp-block-preformatted">if (0 &lt; paidOut[_account])
</pre>



<p>If nothing has ever been paid out, this will always evaluate to false and never throw! Why? The original line is equivalent, after subtracting paidOut from both sides, to:</p>



<pre class="wp-block-preformatted">if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account] &lt; 0)
</pre>



<p>where that first part is actually how much is being paid out. So the check is actually:</p>



<pre class="wp-block-preformatted">if (amountToBePaid &lt; 0)
</pre>



<p>But if amountToBePaid is 0,&nbsp;<strong>the DAO pays you anyway</strong>. To me this doesn’t make much sense — why waste the gas in this manner? I think this is why many people assumed the attacker needed a balance in the reward account to proceed with the attack, something they in fact did not require. The attack works the same way with an empty reward account as with a full one!</p>



<p>Let’s take a look at the DAO’s reward address. The DAO accounting documentation from Slockit pegs this address as&nbsp;<a href="https://github.com/slockit/DAO/wiki/Understanding-the-DAO-accounting">0xd2e16a20dd7b1ae54fb0312209784478d069c7b0</a>.&nbsp;<a href="https://etherscan.io/txsInternal?a=0xd2e16a20dd7b1ae54fb0312209784478d069c7b0&amp;&amp;zero=true&amp;p=220">Check that account’s transactions</a>&nbsp;and you see a pattern: 200 pages of .00000002 ETH transactions to&nbsp;<a href="http://etherscan.io/address/0xf835a0247b0063c04ef22006ebe57c5f11977cc4">0xf835a0247b0063c04ef22006ebe57c5f11977cc4</a>&nbsp;and&nbsp;<a href="https://etherscan.io/address/0xc0ee9db1a9e07ca63e4ff0d5fb6f86bf68d47b89">0xc0ee9db1a9e07ca63e4ff0d5fb6f86bf68d47b89</a>, the attacker’s two malicious contracts (which we cover later). That’s one transaction for each recursive call of withdrawRewardFor, which we described above. So in this case there actually was a balance in the rewards account, and the attacker gets to collect some dust.</p>


<div class="wp-block-image">
<figure class="aligncenter size-full"><img decoding="async" loading="lazy" width="876" height="438" src="./Cryptanalysis of the DAO exploit - Multi-Stage Attack - CRYPTO DEEP TECH_files/image-48.png" alt="Cryptanalysis of the DAO exploit &amp; Multi-Stage Attack" class="wp-image-2338"></figure></div>


<h2 class="wp-block-heading">Step 3: The Big Short</h2>



<p>A number of&nbsp;<a href="https://www.reddit.com/r/ethereum/comments/4olfhh/finding_the_hacker_through_analysis_of_shorts_on">entirely unsubstantiated allegations</a>&nbsp;on social media have pointed to a $3M Ethereum short that occurred on Bitfinex just moments before the attack, claiming this short closed with almost $1M USD of profit.</p>



<p>It’s obvious to anyone constructing or analyzing this attack that certain properties of the DAO (specifically that any split must be running the same code as the original DAO) require an attacker to wait through the creation period of their child DAO (27 days) before withdrawing any coins in a malicious split. This gives the community time to respond to a theft, through either a soft fork freezing attacker funds or a hard fork rolling back the compromise entirely.</p>



<p>Any financially motivated attacker who had attempted their exploit on the testnet would have an incentive to ensure profits regardless of a potential rollback or fork by shorting the underlying token. The&nbsp;<a href="http://www.businessinsider.com/dao-hacked-ethereum-crashing-in-value-tens-of-millions-allegedly-stolen-2016-6?r=UK&amp;amp;IR=T">staggering drop</a>&nbsp;that resulted within minutes of the smart contract that triggered the malicious split provided an excellent profit opportunity, and while there is no proof the attacker took the profit opportunity, we can at least conclude that after all this effort they would have been stupid not to.</p>



<h2 class="wp-block-heading">Step 3a: Preventing Exit (Resistance is Futile)</h2>



<p>Another contingency that the attacker needed to think of is the case that a DAO split occurs before the attacker can finish emptying the DAO. In this case, with another user as sole curator, the attacker would have no access to DAO funds.</p>



<p>Unfortunately the attacker is a smart guy:&nbsp;<a href="https://www.reddit.com/r/ethereum/comments/4okekv/split_daos_vulnerable_to_hack/">there is evidence</a>&nbsp;that the attacker has voted yes on all split proposals that come to term after his own, making sure that he would hold some tokens in the case of any DAO split. Because of a property of the DAO we’ll discuss later in the post, these split DAOs are vulnerable to the same emptying attack we’re describing here. All the attacker has to do is sit through the creation period, send some Ether to the reward account, and propose and execute a split by himself away from this new DAO. If he can execute before the curator of this new DAO updates the code to remove the vulnerability, he manages to squash all attempts to get Ether out of the DAO that aren’t his own.</p>



<p>Notice by the timestamps here that the attacker did this right around the time he started the malicious split, almost as an afterthought. I see this more as an unnecessary middle finger to the DAO than a financially viable attack: having already emptied virtually the entire DAO, going through this effort to pick up any pennies that might be left on the table is probably an attempt to demoralize holders into inaction. Many have concluded, and I agree, that this hints at the attacker’s motivations being a complete destruction of the DAO that goes beyond profit taking. While none of us know the truth here, I do recommend applying your own judgment.</p>



<p>Interestingly enough, this attack was&nbsp;<a href="http://hackingdistributed.com/2016/06/17/thoughts-on-the-dao-hack/">described by Emin Gün Sirer</a>&nbsp;after it had already occurred on the blockchain, but before the public had noticed.</p>


<div class="wp-block-image">
<figure class="aligncenter size-full"><img decoding="async" loading="lazy" width="1344" height="681" src="./Cryptanalysis of the DAO exploit - Multi-Stage Attack - CRYPTO DEEP TECH_files/image-49.png" alt="Cryptanalysis of the DAO exploit &amp; Multi-Stage Attack" class="wp-image-2339"></figure></div>


<h2 class="wp-block-heading">Step 4: Executing the Split</h2>



<p>So we’ve painstakingly described all the boring technical aspects of this attack. Let’s get to the fun part, the action: executing the malicious split. The account that executed the transactions behind the split is&nbsp;<a href="http://etherscan.io/address/0xf35e2cc8e6523d683ed44870f5b7cc785051a77d">0xf35e2cc8e6523d683ed44870f5b7cc785051a77d</a>.</p>



<p>The child DAO they sent funds to is&nbsp;<a href="http://etherscan.io/address/0x304a554a310c7e546dfe434669c62820b7d83490">0x304a554a310c7e546dfe434669c62820b7d83490</a>. The proposal was created and initiated by account&nbsp;<a href="https://live.ether.camp/account/b656b2a9c3b2416437a811e07466ca712f5a5b5a">0xb656b2a9c3b2416437a811e07466ca712f5a5b5a</a>&nbsp;(you can see the call to createProposal in the blockchain history there).</p>



<p>Deconstructing the constructor arguments that created that child DAO leads us to a curator at&nbsp;<a href="https://live.ether.camp/account/da4a4626d3e16e094de3225a751aab7128e96526/contract">0xda4a4626d3e16e094de3225a751aab7128e96526</a>. That smart contract is just a regular multisignature wallet, with most of its past transactions being adding/removing owners and other wallet management tasks. Nothing interesting there.</p>



<p>Johannes Pfeffer on Medium&nbsp;<a href="https://medium.com/@oaeee/the-rise-of-the-dark-dao-72b21a2212e3#.rnb1n01h8">has an excellent blockchain-based reconstruction</a>&nbsp;of the transactions involved in the malicious Child DAO. I won’t spend too much time on such blockchain analysis, since he’s already done a great job. I highly encourage anyone interested to start with that article.</p>



<p>In the next article in the series, we’ll look at the code from the malicious contract itself (containing the exploit that actually launched the recursive attack). In the interest of expedience of release, we have not yet completed such an analysis.</p>


<div class="wp-block-image">
<figure class="aligncenter size-large"><img decoding="async" loading="lazy" width="1024" height="648" src="./Cryptanalysis of the DAO exploit - Multi-Stage Attack - CRYPTO DEEP TECH_files/image-47-1024x648.png" alt="Cryptanalysis of the DAO exploit &amp; Multi-Stage Attack" class="wp-image-2337" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-47-1024x648.png 1024w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-47-300x190.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-47-768x486.png 768w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-47.png 1081w" sizes="(max-width: 1024px) 100vw, 1024px"></figure></div>


<h2 class="wp-block-heading">Step 4a: Extending the Split</h2>



<p>This step is an update to the original update, and covers how the attacker was able to turn a ~30X amplification attack (due to the max size of Ethereum’s stack being capped at 128) to a virtually infinite draining account.</p>



<p>Savvy readers of the above may notice that, even after overwhelming the stack and executing many more malicious splits than was required, the hacker would have their balance zeroed out by the code at the end of splitDAO:</p>



<pre class="wp-block-preformatted">function splitDAO(
  ....
  withdrawRewardFor(msg.sender); // be nice, and get his rewards
  totalSupply -= balances[msg.sender];
  balances[msg.sender] = 0;
  paidOut[msg.sender] = 0;
  return true;
}
</pre>



<p>So how did the attacker get around this? Thanks to the ability to transfer DAO tokens, he didn’t really need to! All he had to do was call the DAO’s helpful&nbsp;<a href="https://github.com/slockit/DAO/blob/v1.0/Token.sol#L92">transfer</a>&nbsp;function at the top of his stack, from his malicious function:</p>



<pre class="wp-block-preformatted">function ​transfer(address _to, uint256 _amount) noEther returns (bool success) {
 ​if (balances[msg.sender] &gt;= _amount &amp;&amp; _amount &gt; 0) {
   ​balances[msg.sender] -= _amount;
   ​balances[_to] += _amount;
   ​...</pre>



<p>By transferring the tokens to a proxy account, the original account would be zeroed out correctly at the end of splitDAO (notice how if A transfers all its money to B, A’s account is already zeroed out by transfer before it can be zeroed out by splitDAO). The attacker can then send the money back from the proxy account to the original account and start the whole process again. Even the update to totalSupply in splitDAO is missed, since p.totalSupply[0] is used to calculate the payout, which is a property of the original proposal and only instantiated once before the attack occurs. So the attack size stays constant despite less available ETH in the DAO with every iteration.</p>



<p>The evidence of two malicious contracts calling into withdrawRewardFor on the blockchain suggests that the attacker’s proxy account was also an attack-enabled contract that simply alternated as the attacker with the original contract. This optimization saves the attacker one transaction per attack cycle, but otherwise appears unnecessary.</p>



<h2 class="wp-block-heading">Was 1.1 Vulnerable?</h2>



<p>Because this vulnerability was in withdrawRewardFor, a natural question to ask is whether the DAO 1.1, with the updated function, was still vulnerable to a similar attack. The answer:&nbsp;<strong>yes</strong>.</p>



<p>Check out the updated function (especially the marked lines):</p>



<pre class="wp-block-preformatted">function withdrawRewardFor(address _account) noEther internal returns (bool _success) {
  if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply &lt; paidOut[_account])
    throw;

  uint reward =
    (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];

  reward = rewardAccount.balance &lt; reward ? rewardAccount.balance : reward;

  paidOut[_account] += reward; // XXXXX
  if (!rewardAccount.payOut(_account, reward)) // XXXXX
    throw;

  return true;
}
</pre>



<p>Notice how paidOut is updated before the actual payout is made now. So how does this affect our exploit? Well, the second time getRewardFor is called, from inside the evil second call to splitDAO, this line:</p>



<pre class="wp-block-preformatted">uint reward =
 (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];
</pre>



<p>will come out to 0. The payOut call will then call _recipient.call.value(0)(), which is the default value for that function, making it equivalent to a call to</p>



<pre class="wp-block-preformatted">_recipient.call()
</pre>



<p>Because the attacker paid for a lot of gas when sending his malicious split transaction, the recursive attack is allowed to continue with a vengeance.</p>



<p>Realizing they needed a 1.2 6 days after a 1.1, on code designed to be secure for years, is probably why the DAO’s puppet masters called it quits.</p>



<h2 class="wp-block-heading">An Important Takeaway</h2>



<p>I think the susceptibility of 1.1 to this attack is really interesting: even though withdrawReward for was not vulnerable by itself, and even though splitDAO was not vulnerable without withdrawRewardFor, the combination proves deadly. This is probably why this exploit was missed in review so many times by so many different people: reviewers tend to review functions one at a time, and assume that calls to secure subroutines will operate securely and as intended.</p>



<p>In the case of Ethereum, even secure functions that involve sending funds could render your original function as vulnerable to reentrancy. Whether they’re functions from the default Solidity libraries or functions that you wrote yourself with security in mind. Special care is required in reviews of Ethereum code to make sure that any functions moving value occur after any state updates whatsoever, otherwise these state values will be necessarily vulnerable to reentrancy.</p>



<p>I won’t cover the fork debate or what’s next for Ethereum and The DAO here. That subject is being beaten to death on every form of social media imaginable.</p>



<p>For our series of posts, the next step is to reconstruct the exploit on the TestNet using the DAO 1.0 code, and demonstrate both the code behind the exploit and the mechanism of attack. Please note that if someone beats me to these objectives, I reserve the right to cap the length of the series at one.</p>



<h2 class="wp-block-heading">Solidity</h2>



<p>Solidity is an object-oriented, high-level language for implementing smart contracts. Smart contracts are programs that govern the behavior of accounts within the Ethereum state.</p>



<p>Solidity is a&nbsp;<a href="https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages">curly-bracket language</a>&nbsp;designed to target the Ethereum Virtual Machine (EVM). It is influenced by C++, Python, and JavaScript. You can find more details about which languages Solidity has been inspired by in the&nbsp;<a href="https://github.com/ethereum/solidity/blob/develop/docs/index.rst#id1">:doc:`language influences &lt;language-influences&gt;`</a>&nbsp;section.</p>



<p>Solidity is statically typed, supports inheritance, libraries, and complex user-defined types, among other features.</p>



<p>With Solidity, you can create contracts for uses such as voting, crowdfunding, blind auctions, and multi-signature wallets.</p>



<p>When deploying contracts, you should use the latest released version of Solidity. Apart from exceptional cases, only the latest version receives&nbsp;<a href="https://github.com/ethereum/solidity/security/policy#supported-versions">security fixes</a>. Furthermore, breaking changes, as well as new features, are introduced regularly. We currently use a 0.y.z version number&nbsp;<a href="https://semver.org/#spec-item-4">to indicate this fast pace of change</a>.</p>



<p>Warning</p>



<p>Solidity recently released the 0.8.x version that introduced a lot of breaking changes. Make sure you read&nbsp;<a href="https://github.com/ethereum/solidity/blob/develop/docs/index.rst#id3">:doc:`the full list &lt;080-breaking-changes&gt;`</a>.</p>



<p>Ideas for improving Solidity or this documentation are always welcome, read our&nbsp;<a href="https://github.com/ethereum/solidity/blob/develop/docs/index.rst#id5">:doc:`contributors guide &lt;contributing&gt;`</a>&nbsp;for more details.</p>



<p>Hint</p>



<p>You can download this documentation as PDF, HTML or Epub by clicking on the versions flyout menu in the bottom-left corner and selecting the preferred download format.<a></a></p>



<h3 class="wp-block-heading"><a href="https://github.com/ethereum/solidity/blob/develop/docs/index.rst#getting-started"></a>Getting Started</h3>



<p><strong>1. Understand the Smart Contract Basics</strong></p>



<p>If you are new to the concept of smart contracts, we recommend you to get started by digging into the “Introduction to Smart Contracts” section, which covers the following:</p>



<ul>
<li><a href="https://github.com/ethereum/solidity/blob/develop/docs/index.rst#id7">:ref:`A simple example smart contract &lt;simple-smart-contract&gt;`</a>&nbsp;written in Solidity.</li>



<li><a href="https://github.com/ethereum/solidity/blob/develop/docs/index.rst#id9">:ref:`Blockchain Basics &lt;blockchain-basics&gt;`</a>.</li>



<li><a href="https://github.com/ethereum/solidity/blob/develop/docs/index.rst#id11">:ref:`The Ethereum Virtual Machine &lt;the-ethereum-virtual-machine&gt;`</a>.</li>
</ul>



<p><strong>2. Get to Know Solidity</strong></p>



<p>Once you are accustomed to the basics, we recommend you read the&nbsp;<a href="https://github.com/ethereum/solidity/blob/develop/docs/index.rst#id13">:doc:`”Solidity by Example” &lt;solidity-by-example&gt;`</a>&nbsp;and “Language Description” sections to understand the core concepts of the language.</p>



<p><strong>3. Install the Solidity Compiler</strong></p>



<p>There are various ways to install the Solidity compiler, simply choose your preferred option and follow the steps outlined on the&nbsp;<a href="https://github.com/ethereum/solidity/blob/develop/docs/index.rst#id15">:ref:`installation page &lt;installing-solidity&gt;`</a>.</p>



<p>Hint</p>



<p>You can try out code examples directly in your browser with the&nbsp;<a href="https://remix.ethereum.org/">Remix IDE</a>. Remix is a web browser-based IDE that allows you to write, deploy and administer Solidity smart contracts, without the need to install Solidity locally.</p>



<p>Warning</p>



<p>As humans write software, it can have bugs. Therefore, you should follow established software development best practices when writing your smart contracts. This includes code review, testing, audits, and correctness proofs. Smart contract users are sometimes more confident with code than their authors, and blockchains and smart contracts have their own unique issues to watch out for, so before working on production code, make sure you read the&nbsp;<a href="https://github.com/ethereum/solidity/blob/develop/docs/index.rst#id17">:ref:`security_considerations`</a>&nbsp;section.</p>



<p><strong>4. Learn More</strong></p>



<p>If you want to learn more about building decentralized applications on Ethereum, the&nbsp;<a href="https://ethereum.org/en/developers/">Ethereum Developer Resources</a>&nbsp;can help you with further general documentation around Ethereum, and a wide selection of tutorials, tools, and development frameworks.</p>



<p>If you have any questions, you can try searching for answers or asking on the&nbsp;<a href="https://ethereum.stackexchange.com/">Ethereum StackExchange</a>, or our&nbsp;<a href="https://gitter.im/ethereum/solidity">Gitter channel</a>.</p>



<p></p>



<h3 class="wp-block-heading"><a href="https://github.com/ethereum/solidity/blob/develop/docs/index.rst#translations"></a>Translations</h3>



<p>Community contributors help translate this documentation into several languages. Note that they have varying degrees of completeness and up-to-dateness. The English version stands as a reference.</p>



<p>You can switch between languages by clicking on the flyout menu in the bottom-left corner and selecting the preferred language.</p>



<ul>
<li><a href="https://docs.soliditylang.org/zh/latest/" target="_blank" rel="noreferrer noopener">Chinese</a></li>



<li><a href="https://docs.soliditylang.org/fr/latest/" target="_blank" rel="noreferrer noopener">French</a></li>



<li><a href="https://github.com/solidity-docs/id-indonesian" target="_blank" rel="noreferrer noopener">Indonesian</a></li>



<li><a href="https://github.com/solidity-docs/ja-japanese" target="_blank" rel="noreferrer noopener">Japanese</a></li>



<li><a href="https://github.com/solidity-docs/ko-korean" target="_blank" rel="noreferrer noopener">Korean</a></li>



<li><a href="https://github.com/solidity-docs/fa-persian" target="_blank" rel="noreferrer noopener">Persian</a></li>



<li><a href="https://github.com/solidity-docs/ru-russian" target="_blank" rel="noreferrer noopener">Russian</a></li>



<li><a href="https://github.com/solidity-docs/es-spanish" target="_blank" rel="noreferrer noopener">Spanish</a></li>



<li><a href="https://docs.soliditylang.org/tr/latest/" target="_blank" rel="noreferrer noopener">Turkish</a></li>
</ul>



<p>Note</p>



<p>We set up a GitHub organization and translation workflow to help streamline the community efforts. Please refer to the translation guide in the&nbsp;<a href="https://github.com/solidity-docs">solidity-docs org</a>&nbsp;for information on how to start a new language or contribute to the community translations.<a></a></p>



<h2 class="wp-block-heading"><a href="https://github.com/ethereum/solidity/blob/develop/docs/index.rst#contents"></a>Contents</h2>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="./Cryptanalysis of the DAO exploit - Multi-Stage Attack - CRYPTO DEEP TECH_files/image-44.png" alt="Cryptanalysis of the DAO exploit &amp; Multi-Stage Attack" class="wp-image-2332" width="839" height="438" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-44.png 452w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-44-300x157.png 300w" sizes="(max-width: 839px) 100vw, 839px"></figure>



<hr class="wp-block-separator has-alpha-channel-opacity">



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="./Cryptanalysis of the DAO exploit - Multi-Stage Attack - CRYPTO DEEP TECH_files/image-43.png" alt="Cryptanalysis of the DAO exploit &amp; Multi-Stage Attack" class="wp-image-2331" width="839" height="715" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-43.png 432w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-43-300x256.png 300w" sizes="(max-width: 839px) 100vw, 839px"></figure>



<hr class="wp-block-separator has-alpha-channel-opacity">



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="./Cryptanalysis of the DAO exploit - Multi-Stage Attack - CRYPTO DEEP TECH_files/image-45.png" alt="Cryptanalysis of the DAO exploit &amp; Multi-Stage Attack" class="wp-image-2333" width="840" height="1033"></figure>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="./Cryptanalysis of the DAO exploit - Multi-Stage Attack - CRYPTO DEEP TECH_files/image-46.png" alt="Cryptanalysis of the DAO exploit &amp; Multi-Stage Attack" class="wp-image-2334" width="841" height="1026" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-46.png 477w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-46-246x300.png 246w" sizes="(max-width: 841px) 100vw, 841px"></figure>



<p></p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<h1 class="wp-block-heading" id="0ff1">Basic concepts</h1>



<p id="8998">To start off, keep in mind that in Ethereum there are two types of accounts: (i) externally owned accounts controlled by humans and (ii) contract accounts controlled by code.&nbsp;<mark>This is important because only contract accounts have associated code, and hence, can have a fallback function.</mark></p>



<p id="ede9">In Ethereum all the action is triggered by transactions or messages (calls) set off by externally owned accounts. Those transactions can be an ether transfer or the triggering of contract code. Remember, contracts can trigger other contracts’ code as well.</p>



<p id="b9a3">Smart contracts are written in high-level programming languages such as&nbsp;<a href="https://solidity.readthedocs.io/en/develop/" rel="noreferrer noopener" target="_blank">Solidity</a>&nbsp;but for those contracts to be uploaded on the blockchain, they need to be compiled into&nbsp;<a href="https://en.wikipedia.org/wiki/Bytecode" rel="noreferrer noopener" target="_blank">bytecode</a>, a low-level programming language executed by the Ethereum Virtual Machine (EVM). Said bytecode can be interpreted with&nbsp;<a href="https://ethereum.gitbooks.io/frontier-guide/content/opcodes,_costs,_and_gas.html" rel="noreferrer noopener" target="_blank">opcodes</a>.</p>



<p id="458d">When a contract calls or sends money to another contract that code compiles in the EVM bytecode, invoking the call function. But, there is a difference: When calling another contract the call function provides specific function identifiers and data, however, when sending money to another contract, the call function has a set amount of&nbsp;<a href="http://ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html#what-is-gas" rel="noreferrer noopener" target="_blank">gas</a>&nbsp;but no data (case b below), and thus, triggers the fallback function of the called contract.</p>



<h1 class="wp-block-heading" id="3e81">The attack</h1>



<p id="66ee">The fallback function abuse played a very important role in the DAO attack. Let’s see what a fallback function is and how it can be used for malicious purposes.</p>



<h2 class="wp-block-heading" id="05d3">Fallback function</h2>



<p id="7c41">A contract can have one anonymous function, known as well as the fallback function. This function does not take any arguments and it is triggered in three cases [1]:</p>



<p id="7ead">a. If none of the functions of the call to the contract match any of the functions in the called contract</p>



<p id="d78a">b. When the contract receives ether without extra data</p>



<p id="b948">c. If no data was supplied</p>



<h2 class="wp-block-heading" id="50b2">Example</h2>



<p id="aef1">The following is sample code for a contract vulnerable to a malicious fallback function of another contract. In this example we have two contracts: (i) the contract Bank (vulnerable contract) and (ii) the contract BankAttacker (malicious contract). Imagine that the contract Bank is the DAO smart contract but much more simplified and the contract BankAttacker is the hacker’s malicious smart contract that emptied the DAO.</p>



<p id="c7bd">The hacker initiates the interaction with contract Bank through its malicious contract and the sequence of the actions is as follows:</p>



<ol>
<li>The first thing the hacker does is send ether (75 wei) to the vulnerable contract through the&nbsp;<em>deposit</em>&nbsp;<em>function&nbsp;</em>of the malicious contract. This function calls the&nbsp;<em>addToBalance function</em>&nbsp;of the vulnerable contract.</li>



<li>Then, the hacker withdraws, through the&nbsp;<em>withdraw function</em>&nbsp;of the malicious contract, the same amount of wei (75), triggering the&nbsp;<em>withdrawBalance</em>&nbsp;<em>function&nbsp;</em>of the vulnerable contract.</li>



<li>The&nbsp;<em>withdrawBalance function</em>&nbsp;first sends ether (75 wei) to the malicious contract, triggering its fallback function, and last updates the&nbsp;<em>userBalances&nbsp;</em>variable<em>&nbsp;</em>(that this piece is done last is very important for the attack).</li>



<li>The malicious fallback function calls the&nbsp;<em>withdrawBalance</em>&nbsp;<em>function&nbsp;</em>again (recursive call), doubling the withdraw, before the execution of the first&nbsp;<em>withdrawBalance function</em>&nbsp;finishes, and thus, without updating the&nbsp;<em>userBalances</em>&nbsp;variable.</li>
</ol>



<p id="615b">In this example, there are only two recursive calls to the&nbsp;<em>withdrawBalance function</em>&nbsp;so the hacker ends up with a balance of 150 wei. They took more than they should (75 wei) because the&nbsp;<em>userBalance&nbsp;</em>variable is the last thing set/updated.</p>



<p id="8bce">One important point is that unlike the JavaScript’s blocks of code, the EVM executes instructions&nbsp;<a href="http://stackoverflow.com/questions/748175/asynchronous-vs-synchronous-execution-what-does-it-really-mean" rel="noreferrer noopener" target="_blank">synchronously</a>, one after the other, and this is why the&nbsp;<em>userBalance</em>&nbsp;variable is updated only after the previous code is finished.</p>



<p id="0986">The following is a more graphic explanation of the example. The instances referred in this graphic are the different states of the contracts saved in the blockchain. In the graphic you will see that the hacker, through his/her/their external account, triggers the malicious contract, so this contract can interact with the vulnerable contract.</p>


<div class="wp-block-image">
<figure class="aligncenter size-large"><img decoding="async" loading="lazy" width="1024" height="797" src="./Cryptanalysis of the DAO exploit - Multi-Stage Attack - CRYPTO DEEP TECH_files/image-40-1024x797.png" alt="Cryptanalysis of the DAO exploit &amp; Multi-Stage Attack" class="wp-image-2324" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-40-1024x797.png 1024w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-40-300x233.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-40-768x598.png 768w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-40.png 1042w" sizes="(max-width: 1024px) 100vw, 1024px"></figure></div>


<p>Last, here is the example in&nbsp;JavaScript, just in case you are not very familiar with Solidity yet.</p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<p>The hacker stole over $100 million in crypto from the Mango Markets Exchange on Tuesday, and may get to keep almost half of it.</p>



<figure class="wp-block-image size-large"><img decoding="async" loading="lazy" width="1024" height="588" src="./Cryptanalysis of the DAO exploit - Multi-Stage Attack - CRYPTO DEEP TECH_files/image-41-1024x588.png" alt="Cryptanalysis of the DAO exploit &amp; Multi-Stage Attack" class="wp-image-2327" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-41-1024x588.png 1024w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-41-300x172.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-41-768x441.png 768w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/image-41.png 1359w" sizes="(max-width: 1024px) 100vw, 1024px"></figure>



<p></p>



<p>Mango DAO has offered a deal to the thief who made off with&nbsp;<a href="https://decrypt.co/111727/solana-defi-trading-platform-mango-markets-loses-100m-in-hack" target="_blank" rel="noreferrer noopener">$100 million</a>&nbsp;in crypto from an exploit in the Mango Markets platform earlier this week—a way to avoid a criminal investigation and pay off bad debt.</p>



<p>The Mango&nbsp;<a href="https://decrypt.co/?post_type=post&amp;p=5728">DAO</a>, a decentralized autonomous organization that manages Mango Markets, has offered the hacker a bug bounty of $47 million, meaning that the thief would be required to send back $67 million worth of&nbsp;<a href="https://decrypt.co/?post_type=post&amp;p=5720">tokens</a>&nbsp;under the terms of the deal.</p>



<p>“We are seeking to make users whole to the extent possible,” the&nbsp;<a href="https://dao.mango.markets/dao/MNGO/proposal/GYhczJdNZAhG24dkkymWE9SUZv8xC4g8s9U8VF5Yprne" target="_blank" rel="noreferrer noopener">Mango DAO proposal says</a>, addressing the thief.</p>



<p>On Tuesday, a hacker was able to steal over $100 million through an exploit in the Mango Markets Solana&nbsp;<a href="https://decrypt.co/?post_type=post&amp;p=25908">DeFi</a>&nbsp;exchange. The attacker temporarily drove up the value of their collateral and then took out loans from the Mango treasury.</p>



<p>The DAO is a so-called Decentralized Autonomous Organization (“DAO”). DAOs run through rules encoded as smart contracts, which in turn are computer programs that facilitate, verify, or enforce the negotiation or performance of a contract, or that make a contractual clause unnecessary. In simple terms, think of any contract between two parties that gets translated into code, so it doesn’t need any external action but does automatically what was agreed. Smart Contracts are a pretty revolutionary and powerful concept by itself and if you want to know more about it, read our separate post on the subject.</p>



<p>The idea of a DAO somewhat is that once launched it can run based on its underlying smart contracts alone. The DAO’s smart contracts are based on Etherum, a public blockchain (which is a distributed database – for more information on blockchain, see&nbsp;<a href="https://planetcompliance.com/2016/03/22/the-basics-of-blockchain/">here</a>) platform with programmable transaction functionality that is also the basis for ether (or ETH), a cryptocurrency. ETH is a cryptocurrency similar to Bitcoin, but very popular since it offers a wider range of services and therefore sometimes considered a considerable challenger of Bitcoin as the leading cryptocurrency.</p>



<p>The DAO is fuelled using ether, which creates DAO tokens. DAO token holders will have the right to vote on investment proposals (proportional to the number of tokens held) as well as the opportunity to receive rewards generated by the output of the work from the contractors’ proposals. Since it is decentralized autonomous organization that is represented only by its smart contracts, it has no physical address and people only interact as contractors or curators, but not in managerial roles in the traditional sense. However, it is supported by a limited company and a cryptocurrency exchange in Switzerland, both chosen with a view to the legal and regulatory framework. The DAO is intended as a form of venture capital vehicle that would invest in projects in the sharing economy. Prior to the attack, the fund’s value was around $150 million in ether.</p>



<p>So while its creators hoped to build a more democratic financial institution that would be safe against the fallibility of humans by trusting the trustless concept of the blockchain and smart contracts, it seems human error is at the bottom of the heist.</p>



<p>Though it is not entirely certain yet how the money has been stolen, it appears that the hacker exploited a programing mistake in the code of the DAO. Weaknesses in the code had already been highlighted before and experts in the field had already called to fix critical problems. At this point it is important to recall that as a blockchain-enabled organization, the DAO is completely transparent and everything is done by the code, which anyone can see and audit. So, it seems that what happened – in a very simplified way – was that the hacker sent repeated transaction request to transfer funds to a DAO clone. Because of the programming error, the system possibly did not immediately update the balance, allowing the attacker to drain the account.</p>



<p>Since then the discussion has been how to respond to the attack. In an initial response, Vitalik Buterin, one of Ethereum’s founders, publicly asked online currency exchanges to suspend trading of ether and DAO tokens as well as deposits and withdrawals of the cryptocurrency.</p>



<p>Because of a restriction in the code pay-outs are delayed for at least one week, possibly even longer, the hacker will not be able to access the funds and give The DAO community some time. Several options are currently discussed: The community could decide to do nothing, preserve the system and let the DAO token holders loose their investment. Or the so-called “hard-fork” where the Ethereum community could decide to roll back all transactions to a specific point in time before the attack. Or the network could be updated to ensure that all transactions from the hacker’s ether address are blocked, basically freezing the account and trying to exploit a similar programing error to “steel” the money back since the DAO clone is likely to contain the same code structure that made the original attack possible.</p>



<p>Regardless which course is decided on, what are the likely consequences for the DAO, Ethereum and the Blockchain in general after this incident?<br>Stephen Tual, COO of Slock.it, the company that had worked on the development of The DAO, stated that The DAO is definitely going to close. Whether that is the case is to be seen as in a leaderless organization no one person alone can decide on the fate of the organisation. The future of the investment vehicle is cast into serious doubt in any case by the theft itself, as it is questionable whether anyone would put money in a construction that has a proven vulnerability even when its makers promise to fix the issues. Trust, after all, is relevant even for a trustless concept when it comes to money.</p>



<p>The more damaging aspect for the DAO, but also for Ethereum and potentially even the blockchain technology lies potentially in the actions to get the ether back. In comments across the web it has been compared with a bailout for banks that are too big to fail and that investors simply didn’t understand the risks of their investments. If the system is supposed to be flawless and save against tempering, isn’t meddling with it because of an, albeit very significant and expensive, programming error, undermining the whole idea? If people decide on whether transactions are to be reversed or not instead of the underlying smart contract, what is the worth of such an instrument if it’s only useful if anything goes according to plan?</p>



<p>Regardless what happens next it is an immensely important case as well from a legal and regulatory perspective: One tweet even hinted that a short bet on Ether was placed on one cryptocurrencies exchange shortly before the attack, which reminds us that traditional regulatory aspects like Market Abuse are more than relevant in the digital age. The tweet demanded an investigation though that raises the interesting questions about jurisdiction, governing legal frameworks and regulation, but that is only a side aspect to the story for now (though it would make sense from an economical perspective since the thief is unlikely to be able to access the Ether he stole and in that way could gain a monetary benefit from the heist).</p>



<p>In an interesting post at&nbsp;<a href="http://www.coindesk.com/sue-dao-hacker/">Coindesk</a>, a US lawyer discussed the incident from a perspective of criminal law (Theft? Yes!), civil law (sue the hacker? Sure, seems everything can be sued) and tort law.</p>



<p>And even more interesting is the question whether the hacker only exploited a loophole in the code. In a message to the DAO and the Ethereum community, which is allegedly from the person responsible for the attack, the hacker described his action simply as using an intentional feature of the code and stated that any action to get the funds back, would amount to seizure of my legitimate and rightful ether, claimed legally through the terms of a smart contract, threatening trying to do so with legal action.</p>



<p>Everything is in flux: at the time of writing this, the DAO community is voting on whether to take action and, if so, in what form. Someone claiming to be an intermediary on behalf of the attackers has published a note, making it look like their holding the stolen ether ransom, and tweets on the subject get seemingly posted every second.</p>



<p>So to summarise, plenty of open questions, an uncertain future for the DAO, but maybe there is a silver lining that comes from this. Maybe this is only a costly episode on a steep learning curve, similar to other forms of innovation, and maybe this will lead to more care, diligence and scrutiny in future blockchain projects, which in the end might not be so bad after all.</p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<h2 class="wp-block-heading">Literature:</h2>



<ul>
<li><em><a href="https://cryptodeep.ru/doc/Understanding_a_Revolutionary_and_Flawed_Grand_Experiment_in_Blockchain__The_DAO_Attack_Journal_of_Cases_on_Information_Technology.pdf" target="_blank" rel="noreferrer noopener">Understanding a Revolutionary and Flawed Grand Experiment in Blockchain: The DAO Attack Journal of Cases on Information Technology</a></em></li>
</ul>



<hr class="wp-block-separator has-alpha-channel-opacity">



<h1 class="wp-block-heading" id="22d1">Conclusion</h1>



<p id="ad85">I’ve learned a lot understanding the DAO exploit, mainly that programming smart contracts is not an easy task and it should be done rigorously. I still have lots of unsolved questions such as: Do we need fallback functions at all? Apparently this was fixed in the new version of Solidity. However, the problem is still present at the EVM level because a hacker can program in opcode and avoid the Solidity’s security </p>



<hr class="wp-block-separator has-alpha-channel-opacity">



<p><strong><a href="https://github.com/demining/Dao-Exploit" target="_blank" rel="noreferrer noopener">GitHub</a></strong></p>



<p><strong><a href="https://t.me/cryptodeeptech" target="_blank" rel="noreferrer noopener">Telegram:&nbsp;https://t.me/cryptodeeptech</a></strong></p>



<p><a href="https://youtu.be/-QDYiKCwOaA" target="_blank" rel="noreferrer noopener"><strong>Video: https://youtu.be/-QDYiKCwOaA</strong></a></p>



<p><strong><a href="https://cryptodeeptech.ru/dao-exploit" target="_blank" rel="noreferrer noopener">Source: https://cryptodeeptech.ru/dao-exploit</a></strong></p>



<hr class="wp-block-separator has-alpha-channel-opacity">


<div class="wp-block-image">
<figure class="aligncenter size-large"><img decoding="async" loading="lazy" width="1024" height="576" src="./Cryptanalysis of the DAO exploit - Multi-Stage Attack - CRYPTO DEEP TECH_files/044-1-1024x576.png" alt="Cryptanalysis of the DAO exploit &amp; Multi-Stage Attack" class="wp-image-2343" srcset="https://cryptodeeptech.ru/wp-content/uploads/2023/06/044-1-1024x576.png 1024w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/044-1-300x169.png 300w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/044-1-768x432.png 768w, https://cryptodeeptech.ru/wp-content/uploads/2023/06/044-1.png 1280w" sizes="(max-width: 1024px) 100vw, 1024px"></figure></div>


<p></p>



<p></p>
	</div><!-- .entry-content -->

	
